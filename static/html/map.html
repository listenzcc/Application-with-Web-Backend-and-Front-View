<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Guides</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.17.0-beta.1/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.17.0-beta.1/mapbox-gl.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 800px;
            height: 800px;
            z-index: 10;
        }

        .click-through {
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div>
        <div id="map"></div>
        <div id="overlap" class="click-through" style="z-index:100; position: fixed">
        </div>
        <div id="simulation" class="click-through" style="z-index:200; position: fixed">
        </div>
    </div>
    <div style="z-index: 200; position: absolute">
        <!-- Options for session frames -->
        <select id="sessionSelect">
        </select>
    </div>

    <script>
        const sessionStr = "{{session}}";
        const sessionApiUrl = `/get_fds_simulation_result/${sessionStr}`;

        /**
         * 定时检查模拟结果是否生成完成
         */
        function timelyCheck() {
            const response = fetch(sessionApiUrl);
            response.then(async (response) => {
                if (!response.ok) {
                    throw new Error(`HTTP错误: ${response.status}`);
                }

                const resp = await response.json();
                console.log(resp)
                // 如果生成结果中不包含 'generated.gif'，则继续定时检查
                if (!resp.files.includes('generated.gif')) {
                    setTimeout(timelyCheck, 1000);
                } else {
                    // 结果生成完成，填充下拉选项
                    const sessionSelect = document.getElementById('sessionSelect');
                    resp.files.forEach(file => {
                        if (file.endsWith('.png')) {
                            const option = document.createElement('option');
                            option.value = file;
                            option.text = file;
                            sessionSelect.appendChild(option);
                        }
                    });
                    sessionSelect.onchange = () => {
                        // 触发simulation overlay的更新
                        setupSimulationOverlay();
                    };
                }

            });
        }
        timelyCheck();
    </script>

    <script>
        mapboxgl.accessToken = 'pk.eyJ1IjoibGlzdGVuemNjIiwiYSI6ImNrMzU5MmpxZDAxMXEzbXQ0dnd4YTZ2NDAifQ.GohcgYXFsbDqfsi_7SXdpA';
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/standard',
            projection: 'globe',
            zoom: "{{zoom}}",
            // center: [116.3912757, 39.906217] // 经度，纬度
            center: ["{{lon}}", "{{lat}}"] // 经度，纬度
        });

        console.log(`Simulation session: ${sessionStr}`);

        map.addControl(new mapboxgl.NavigationControl());
        // map.scrollZoom.disable();

        map.on('style.load', () => {
            map.setFog({});
        });

        // Create and setup canvas after map loads
        map.on('load', () => {
            setupCanvasOverlay();
            setupCanvasOverlay1();
            setupSimulationOverlay();
        });

        /**
         * 设置覆盖在地图上的模拟仿真Canvas
         */
        function setupSimulationOverlay() {
            // Similar to setupCanvasOverlay, but for simulation overlay
            const simulationDiv = document.getElementById('simulation');
            simulationDiv.innerHTML = ''; // Clear previous content
            const mapDiv = document.getElementById('map');
            // Create canvas element
            const canvas = document.createElement('canvas');
            canvas.id = 'simulationCanvas';
            simulationDiv.appendChild(canvas);
            // Get canvas context
            const ctx = canvas.getContext('2d');

            // Set canvas dimensions to match the container
            function resizeCanvas() {
                canvas.width = mapDiv.offsetWidth;
                canvas.height = mapDiv.offsetHeight;
                drawOnCanvas();
            }

            // Initial resize
            resizeCanvas();

            function drawOnCanvas() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const frame = document.getElementById('sessionSelect').value;
                const url = `/get_fds_simulation_frame?session=${sessionStr}&frame=${frame}`;//&_=${new Date().getTime()}`;
                const image = new Image();
                image.src = url;
                image.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
                    console.log('Simulation image loaded and drawn on canvas, image=', image);
                    // 获取图像数据
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;

                    let a = 0;
                    for (let i = 0; i < data.length; i += 4) {
                        a += data[i];
                    }
                    console.log(a);

                    // 处理每个像素
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];      // 红色通道（灰度图中三个通道值相同）
                        const g = data[i + 1];  // 绿色通道
                        const b = data[i + 2];  // 蓝色通道
                        const a = data[i + 3];  // 透明度通道

                        // 计算灰度值（取平均值）
                        const gray = (r + g + b) / 3;

                        if (gray === 0) {
                            // 黑色像素：完全透明
                            data[i + 3] = 0;
                        } else {
                            // 非黑色像素：使用Reds配色方案
                            // 将灰度值映射到红色强度（0-255）
                            // 同时保持一定透明度以保留原始灰度层次
                            const redIntensity = Math.floor((gray / 255) * 255);

                            // 设置红色通道
                            data[i] = redIntensity;      // 红色
                            data[i + 1] = Math.floor(redIntensity * 0.1);  // 少量绿色
                            data[i + 2] = Math.floor(redIntensity * 0.1);  // 少量蓝色

                            // 根据灰度值设置透明度（越白越不透明）
                            data[i + 3] = Math.floor((gray / 255) * 255);
                        }
                    }

                    // 将处理后的图像数据放回画布
                    ctx.putImageData(imageData, 0, 0);

                    console.log('Simulation image loaded and drawn with red color scheme');
                };
            }
        }

        /**
         * 设置覆盖在地图上的Canvas
         */
        function setupCanvasOverlay() {
            const overlapDiv = document.getElementById('overlap');
            const mapDiv = document.getElementById('map');

            // Remove existing canvas if any
            const existingCanvas = overlapDiv.querySelector('canvas');
            if (existingCanvas) {
                existingCanvas.remove();
            }

            // Create canvas element
            const canvas = document.createElement('canvas');
            canvas.id = 'overlayCanvas';
            overlapDiv.appendChild(canvas);

            // Get canvas context
            const ctx = canvas.getContext('2d');

            // Set canvas dimensions to match the container
            function resizeCanvas() {
                canvas.width = mapDiv.offsetWidth;
                canvas.height = mapDiv.offsetHeight;
                drawOnCanvas();
            }

            // Initial resize
            resizeCanvas();

            // Handle window resize
            window.addEventListener('resize', resizeCanvas);

            // Handle map movements to update overlay if needed
            map.on('move', drawOnCanvas);
            map.on('zoom', drawOnCanvas);

            // Example drawing function
            function drawOnCanvas() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Example: Draw a semi-transparent rectangle
                ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                ctx.fillRect(100, 100, 200, 150);

                // Example: Draw a circle
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, 50, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 255, 0.3)';
                ctx.fill();

                // Example: Draw text
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.fillText('Canvas Overlay', canvas.width / 2 - 50, canvas.height / 2);

                // Example: Draw lines
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(canvas.width, canvas.height);
                ctx.moveTo(canvas.width, 0);
                ctx.lineTo(0, canvas.height);
                ctx.stroke();

                // You could also draw based on map coordinates
                // Example: Draw at a specific geographic location
                const coordinates = [116.3912757, 39.906217];
                const pixelPosition = map.project(coordinates);

                ctx.beginPath();
                ctx.arc(pixelPosition.x, pixelPosition.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 0, 0.4)';
                ctx.fill();

                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.fillText('Beijing', pixelPosition.x + 25, pixelPosition.y);
            }

            // If you want interactive canvas (remove pointer-events: none from CSS)
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                console.log(`Canvas clicked at: ${x}, ${y}`);

                // Convert to map coordinates
                const lngLat = map.unproject([x, y]);
                console.log(`Map coordinates: ${lngLat.lng}, ${lngLat.lat}`);

                // Draw something at click position
                ctx.beginPath();
                ctx.arc(x, y, 15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 165, 0, 0.5)';
                ctx.fill();
            });
        }

        /**
         * 独立函数：从指定API获取传感器数据并绘制到指定canvas上
         * @param {string} apiUrl - 传感器数据API地址
         * @param {HTMLCanvasElement} canvas - 要绘制的canvas元素
         * @param {Object} customStyles - 自定义样式（可选）
         * @returns {Promise<Array>} 返回传感器数据数组
         */
        async function drawSensorsOnCanvas(apiUrl, canvas, customStyles = {}) {
            // 验证参数
            if (!canvas || !(canvas instanceof HTMLCanvasElement)) {
                throw new Error('有效的canvas元素是必需的');
            }

            try {
                // 1. 获取传感器数据
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    throw new Error(`HTTP错误: ${response.status}`);
                }

                const sensors = await response.json();

                // 2. 获取canvas上下文
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    throw new Error('无法获取canvas上下文');
                }

                // 3. 合并默认样式和自定义样式
                const defaultStyles = {
                    humidity: {
                        color: 'rgba(65, 105, 225, 0.8)',
                        radius: 8,
                        borderColor: 'rgba(30, 144, 255, 1)',
                        labelColor: 'black'
                    },
                    temp: {
                        color: 'rgba(220, 20, 60, 0.8)',
                        radius: 10,
                        borderColor: 'rgba(255, 69, 0, 1)',
                        labelColor: 'black'
                    },
                    default: {
                        color: 'rgba(50, 205, 50, 0.8)',
                        radius: 8,
                        borderColor: 'rgba(34, 139, 34, 1)',
                        labelColor: 'black'
                    },
                    fontSize: 12,
                    fontFamily: 'Arial'
                };

                const styles = { ...defaultStyles, ...customStyles };

                // 4. 清除canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 5. 绘制每个传感器
                sensors.forEach(sensor => {
                    drawSingleSensor(ctx, canvas, sensor, styles);
                });

                // 6. 返回传感器数据供进一步使用
                return sensors;

            } catch (error) {
                console.error('绘制传感器数据失败:', error);
                throw error;
            }
        }

        /**
         * 绘制单个传感器
         */
        function drawSingleSensor(ctx, canvas, sensor, styles) {
            // 确定传感器类型
            const sensorId = sensor.sensor_id.toLowerCase();
            let type = 'default';

            if (sensorId.includes('humidity')) {
                type = 'humidity';
            } else if (sensorId.includes('temp')) {
                type = 'temp';
            }

            const style = styles[type] || styles.default;

            // 转换坐标 (0-1 相对坐标 → 像素坐标)
            const x = sensor.x_position * canvas.width;
            const y = sensor.y_position * canvas.height;

            // 保存上下文状态
            ctx.save();

            // 绘制传感器点
            drawSensor(ctx, x, y, sensor, style, styles.fontSize, styles.fontFamily);

            // 恢复上下文状态
            ctx.restore();
        }

        /**
         * 绘制单个传感器点的具体实现
         */
        function drawSensor(ctx, x, y, sensor, style, fontSize, fontFamily) {
            // 绘制外圆边框
            ctx.beginPath();
            ctx.arc(x, y, style.radius + 2, 0, Math.PI * 2);
            ctx.fillStyle = style.borderColor;
            ctx.fill();

            // 绘制内圆主体
            ctx.beginPath();
            ctx.arc(x, y, style.radius, 0, Math.PI * 2);
            ctx.fillStyle = style.color;
            ctx.fill();

            // 绘制中心点
            ctx.beginPath();
            ctx.arc(x, y, style.radius / 3, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();

            // 绘制传感器ID
            ctx.fillStyle = style.labelColor;
            ctx.font = `bold ${fontSize}px ${fontFamily}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // 添加文字阴影
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 2;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;

            ctx.fillText(sensor.sensor_id, x, y + style.radius + 8);

            // 可选：绘制最后更新时间
            if (sensor.last_updated) {
                const timeText = new Date(sensor.last_updated).toLocaleTimeString();
                ctx.font = `10px ${fontFamily}`;
                ctx.fillText(timeText, x, y + style.radius + 25);
            }

            if (sensor.value) {
                const value = sensor.value.toFixed(4);
                ctx.font = `10px ${fontFamily}`;
                ctx.fillText(value, x, y + style.radius + 40);

            }
        }

        // 使用示例：
        // 在你的setupCanvasOverlay函数中：
        function setupCanvasOverlay1() {
            // ... 现有的canvas创建代码 ...

            const canvas = document.getElementById('overlayCanvas');

            // 初始绘制
            drawSensorsOnCanvas(
                'latest_sensor_data',
                canvas
            ).then(sensors => {
                console.log(`绘制了 ${sensors.length} 个传感器`);
            });

            // 定时更新
            setInterval(() => {
                drawSensorsOnCanvas(
                    'latest_sensor_data',
                    canvas
                ).then(sensors => {
                    // console.log(`更新了 ${sensors.length} 个传感器`);
                });
            }, 1000); // 每1秒更新一次
        }
    </script>
</body>

</html>